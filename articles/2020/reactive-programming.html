<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="description" content="Reactive programming."> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="stylesheet" href="https://unpkg.com/mvp.css"> <link rel="stylesheet" href="https://unpkg.com/prismjs@1.20.0/themes/prism-okaidia.css"> <link rel="stylesheet" href="/style.css"> <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js"></script> <script defer src="https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js"></script> <script defer src="https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"></script> <title>Reactive programming.</title> </head> <body> <header> <nav> <ul> <li><a href="/">Home</a></li> <li><a href="/articles">Articles</a></li> </ul> <ul> <li><a href="https://github.com/mattmezza"><i class="fab fa-github"></i></a></li> <li><a href="https://twitter.com/_mattmezza_"><i class="fab fa-twitter"></i></a></li> <li><a href="https://linkedin.com/in/matteomerola"><i class="fab fa-linkedin"></i></a></li> <li><a href="https://telegram.me/mattmezza"><i class="fab fa-telegram"></i></a></li> <li><a href="mailto:mattmezza@gmail.com"><i class="fas fa-envelope"></i></a></li> </ul> </nav> <h1>Reactive programming.</h1> <p>28th June 2020</p> </header> <main> <section> <article class="has-text-justified-book"><p>The first application of this technique is dated back to 1969 when Remy Landau and Rene Pardo came up with LANPAR Technologies<sup><a href="#f1" id="s1">1</a></sup></p> <p>Reactive programming is based on mainly 3 points:</p> <ol type="1"> <li>Data streams</li> <li>Functional programming</li> <li>Asynchronous observers</li> </ol> <p>An encompassing definition of Reactive Programming might be the following:</p> <blockquote> <p>“The essence of functional reactive programming is to specify the dynamic behavior of a value completely at the time of declaration.”</p> </blockquote> <p>One of the biggest applications of Reactive Programming is the development of Graphical User Interfaces. This particular kind of software applications show in fact a very high level of asynchronous interactivity. Generally, data flows in a streams of operations performed by users. Each action should be reflected in a rapid, flawless feedback on the screen. This feedback must be prompt and clear because it will be feeding the next actions performed by the user.</p> <p>Reactive programming focuses on:</p> <ul> <li>performances</li> <li>declarative approach</li> </ul> <h3 id="data-streams">Data streams</h3> <p>If you are able to specify, in a declarative way, the dynamic behavior of something, then you are not bound anymore to a mere input and output flow. You instead can switch to an adoption of a continuous stream of data that flows through a chain of operations declared beforehand and ends up reflected in one or more final values.</p> <p>This way of working gives you a high degree of freedom and keeps the complexity of dealing with multiple sequences of data points to a very low level. You might be in facts surprised if you give a look at some of the spreadsheets of people with 0 knowledge about programming. Even though they fully ignore some of the concepts we are most familiar with and even if they don’t have (not even remotely sometimes) the discipline that we instead practice on a daily basis, they are able to support their businesses by setting up a few functional blocks in a spreadsheets and work with streams of diverse data.</p> <p>In the realm of GUIs, and especially in GUIs with high interactivity, you can see everything as a stream: - a button might stream click events - an input field might stream events containing its value everytime said value changes - the window object might stream events containing the mouse x,y position - an http client might stream a list of post objects everytime it calls the <code>/posts</code> endpoint - etc…</p> <h3 id="functional-programming">Functional programming</h3> <p>Reactive Programming leverages Functional Programming to be able to fully describe the behavior of a component ahead of time in a declarative way. It is a little bit like writing a function in a spreadsheet cell: functions are used to interact with streamed data and perform actions accordingly.</p> <h3 id="asynchronous-observers">Asynchronous observers</h3> <p>One of the most powerful aspect of Reactive Programming is probably its ability to support asynchronicity of execution. As a matter of facts, once the behavior is fully described in a declarative way, each value can be tracked asynchonously allowing thus snappier results.</p> <h3 id="performances">Performances</h3> <p>When you are working in the realm of CPU-bound or memory-bound applications (think about mobile or embedded for instance), performance assumes a much greater role. As data flows into the system, you want to minimize the amount of changes you perform in order to maximize the throughput of the entire system. Reactive Programming is a great way to achieve this goal.</p> <h4 id="forward-referencing">Forward referencing</h4> <p>Back in 1969, when the first spreadsheet was invented, computers were not so powerful and could not affort full repaint most of the times. Forward referencing allowed to keep track of what value depends on what values creating thus a dependency chain. This chain then could be taken into account when evaluating the values by performing a topological order evaluation.</p> <p>If <code>A &lt;- B, C</code> (A depends on B and C) and <code>C &lt;- B</code> (C depends on B), a topological evaluation would result in:</p> <pre class="javascript"><code>B = eval(), C = eval(B), A = eval(B, C)</code></pre> <p><code>B</code> is evaluated first, <code>C</code> is evaluated afterwards and lastly <code>A</code> is evaluated too. Note that by knowing the dependency chain, together with what you also know when to re-evaluate specific values.</p> <h3 id="declarative-approach">Declarative approach</h3> <p>Probably one of the most important aspect of Reactive Programming is the ability to self-document and entirely describe the behavior of a component in a purely declarative way. Have you ever asked yourself why spreadsheets are so well understood by a wide variety of people? When you don’t know how a cell comes up with a specific value, what is the first thing you do?</p> <p>In a well defined spreadsheet, chances are that in 1 or max 2 steps you are able to figure out the particular reason behind a specific behavior.</p> <p>This is mainly because each component is defined in a declarative approach with an outcome oriented philosophy.</p> <h2 id="implementation-in-different-stacks">Implementation in different stacks</h2> <p>Reactive Programming frameworks have been implemented in many technological stacks<sup><a href="#f2" id="s2">2</a></sup>, especially in stacks used for building UIs and CPU and battery bound.</p> <ul> <li>RxJs (especially used in Angular)</li> <li>RxJava (especially used in Android)</li> <li>RxAndroid</li> <li>Rx.NET</li> <li>RxScala</li> <li>RxClojure</li> <li>RxSwift</li> <li>RxKotlin</li> <li>RxPY</li> <li>Rx.rb</li> </ul> <p>Although many component framework on the web leverage some sort of Reactive Programming library, some instead use Reactive Programming by implementing it directly.</p> <h2 id="thinking-reactive">Thinking reactive</h2> <p>Reactive Programming is more than a paradigm shift. Its so wide spectrum of applications makes it suitable for big and small software projects keeping a sweet spot for apps with high level of interactivity and that deal with streams of data. But how does it work on a more specific level? How can I get started with it?</p> <h3 id="the-basics">The basics</h3> <p>You have to wrap your head around some important notions:</p> <ul> <li>Subjects</li> <li>Observables</li> <li>Observers</li> <li>Subscriptions</li> </ul> <h4 id="subjects">Subjects</h4> <p>A subject represents the value that will be streamed/observed/subscribed to. It also embodies the strategy with which events will be emitted in the stream.</p> <p>Examples:</p> <ul> <li><strong>Subject&lt;Post[]&gt;</strong> a subject that streams <code>Post</code> objects: starts with <code>null</code> and does not keep state everytime a new array of <code>Post</code> is emitted</li> <li><strong>BehaviorSubject&lt;Post[]&gt;</strong> a subject that streams <code>Post</code> objects: starts with a default value and keeps the last emitted array of <code>Post</code> objects</li> <li>etc…</li> </ul> <h4 id="observables">Observables</h4> <p>Everything can be an observable! You can see an observable as a wrapper around the <strong>thing</strong> you want to observe. In the previous example, you can see <code>Post[]</code> as an observable (<code>Observable&lt;Post[]&gt;</code>).</p> <p>Cool thing you can do with observables??</p> <ul> <li>filtering: skipping, taking until, taking while, etc…</li> <li>creation: emit every X seconds, create from array, etc…</li> <li>transformation: mapping, flattening, combining, etc…</li> </ul> <h4 id="observers">Observers</h4> <p>So you’ve got your subject from which you can derive your observable, cool! The last thing you need now is an observer: who will actually be there waiting for new values from the data stream?</p> <p>Here is where you can also understand another reason why reactive programming is cool: depending on the actual platform you are on, the observers can vary. On the web, your code very like runs on the main thread in an event loop, so your observers have little space to scale. On other platforms, there might be different options for the way observables are observed (e.g. multithreaded, actor-based, etc…)</p> <p>The observer contains the logic that handles three main events:</p> <ul> <li><strong>next</strong>: fired every time a new value is emitted on the stream</li> <li><strong>error</strong>: fired when an error occured in the stream or in another stream back up in the dependency chain</li> <li><strong>complete</strong>: fired once when the stream has completed and will not emit any more values</li> </ul> <h4 id="subscriptions">Subscriptions</h4> <p>Once you start observing a particular stream of observable, the way you perform actions or evaluations is by subscribing observers to observables.</p> <pre class="javascript"><code>const s = obs.subscribe(val =&gt; ..., err =&gt; ..., () =&gt; ...)</code></pre> <p>A subscription is useful also because you can decide, at run time (depending on user input), to cancel the subscription and stop reacting to events.</p> <pre class="javascript"><code>s.unsubscribe()</code></pre> <h4 id="note-on-react">Note on React</h4> <p>React, although the name might suggest otherwise, it’s not really a clear example of a Reactive Programming component framework. By default, in fact, when some state changes, React will actually re-evaluate every component and reconcile only the bits that should change using a virtual DOM<sup><a href="f3" id="s3">3</a></sup>.</p> <p><br> <sup><a href="#s1" id="f1">1</a></sup> <a href="http://reactivex.io/languages.html">Spreadsheets on Wikipedia</a></p> <p><sup><a href="#s2" id="f2">2</a></sup> <a href="http://reactivex.io/languages.html">ReactiveX</a></p> <p><sup><a href="#s3" id="f3">3</a></sup> React gives you some more tools to reduce the amount of work that has to be done during the reconciliation phase (see <code>useMemo(...)</code> for example).</p></article> </section> </main> <footer> <p> <small>All rights reserved &copy; 2022 – Matteo Merola</small> </p> </footer> <script defer data-domain="matteo.merola.co" src="https://plausible.io/js/plausible.js"></script> </body> </html>
